{"posts":[{"title":"[Top] Training Records - Minming Fan Club","text":"Season: 2023-2024 (the 48th ICPC &amp; the 9th CCPC) Team Members: Yixiong GAO(G), Zhehan YU(YU), Shangkun ZHENG(Z), Yu HE(H), Fangzhao YAN(YA). Contests Date Contest Team Rank Solved Award 2023/09/23 ICPC EC-Online II G,YU,YA 71 / 2339 7 / 13 - 2023/10/28 IEEE Xtreme 17.0 G,YU,Z 11 / 7091 19 / 26 Hong Kong Championship 2023/11/05 CCPC Harbin Onsite G,YU,Z 14 / 244 6 / 13 Gold Medal 2023/11/12 CCPC Shenzhen Onsite G,YU,Z 85 / 268 4 / 13 Bronze Medal 2023/11/19 ICPC Macau Regional (Observer) G,YU 17 / 77 5 / 11 Quickest Solver (E, J) 2023/12/04 ICPC Jinan Regional G,YU,H 45 / 346 7 / 13 Silver Medal 2023/12/10 ICPC Hangzhou Regional G,YU,YA 20 / 435 6 / 13 Gold Medal 2024/01/13 ICPC EC-Final G,YU,YA 47 / 280 6 / 13 Silver Medal Virt. Contests Date Contest Team Solved UpSolved 2023/09/19 2018-2019 ICPC Asia Jiaozuo Regional G,YU 7 / 12 7 / 12 2023/09/21 2019-2020 ICPC Southeastern European Regional G,YU,YA 7 / 11 7 / 11 2023/09/26 2020-2021 ICPC Asia Seoul Regional G,YU 9 / 12 9 / 12 2023/09/27 2022-2023 ICPC Asia Manila Regional G,YU,Z 10 / 12 10 / 12 2023/09/30 The 46th ICPC Southwestern European Regional G,YU,YA 9 / 12 9 / 12 2023/10/12 COMPFEST 13 - Finals G,H,Z 10 / 13 10 / 13 2023/10/14 COMPFEST 14 - Preliminary G,YU,Z 10 / 13 10 / 13 2023/10/17 The 47th ICPC Asia Shenyang Regional G,YU 5 / 13 6 / 13 2023/10/19 2018-2019 ICPC Asia East Continent Finals G,YU,Z 4 / 12 4 / 12 2023/10/20 The 45th ICPC NERC Russian Regional G,YU,Z 13 / 14 13 / 14 2023/10/21 2017-2018 ICPC Asia East Continent League Finals G,YU,Z 9 / 13 9 / 13 2023/10/30 2023年中国大学生程序设计竞赛女生专场 G,YU,Z 9 / 12 9 / 12 2023/11/01 2020 CCPC Finals G,YU,Z 6 / 13 6 / 13 2023/11/10 The 9th CCPC Guilin Onsite G,YU,Z 6 / 13 7 / 13 2023/11/22 The 47th ICPC Central Europe Regional G,YU,H 7 / 13 8 / 13 2023/11/25 The 48th ICPC Asia Nanjing Regional G,YU,H 7 / 13 7 / 13 2023/11/26 2023 ICPC Southwestern European Regional G,YU,YA 6 / 13 6 / 13 2023/11/29 The 1st UCup, Stage 4: Ukraine G,YU,H 8 / 14 9 / 14 2023/12/06 The 48th ICPC Asia Hefei Regional G,YU 6 / 12 7 / 12 2024/01/04 The 48th ICPC NERC Regional G,YU,YA 7 / 12 7 / 12 2024/01/06 2018-2019 ICPC NEERC Finals G,YU,YA 8 / 13 8 / 13 2024/01/09 The 48th ICPC Asia Shenyang Regional G,YU,YA 6 / 12 6 / 12","link":"/summary/minming-fan-club/"},{"title":"The 48th ICPC Asia Hangzhou Regional Contest","text":"补题链接, 英文题面, 中文题面, 官方题解 题目思维量大但比较套路，感觉需要多积累，没想到最后赢在了模拟写的快 ID Difficulty (0-5) Topic Status Code","link":"/contest/icpc/48/hangzhou/"},{"title":"Codeforces Round 924 (Div. 2)","text":"Solved: 4 of 6 | Rank: 258 | Performance: 2061 ID Difficulty (0-5) Topic Status Code A 0 Brute Force Solved A.cpp B 0 Two Pointers Solved B.cpp C 1 Math Solved C.cpp D 1 Greedy Solved D.cpp E 3 Dynamic Programming Upsolved E.cpp F 4 Combinatorics, Segment Tree Upsolved F.cpp E. Modular Sequence 给定 $n,x,y,s$ ，问是否能构造以恶搞长度为 $n$ 的数列 $a$ ，满足： $a_1=x$ $a_i=a_{i-1}+y$ 或 $a_i=a_{i-1}\\mod y$ $\\sum_{i=1}^n a_i= s$ 令 $r=x\\mod y$，不妨令 $s’=(s-nr)/y, x’=(x-r)/y$ ，选择改成置为 $0$ 或加 $1$ 。 我们称连续增长的为一段。则答案中除了第一段都是从 $0$ 开始的。 因为求和增长的速度是平方级别的，所以每一段连续的长度不会超过 $O(\\sqrt{s})$ 。 把这 $O(\\sqrt{s})$ 中不同的段按照长度拿出来做个完全背包，求出凑出某个数所需的最小长度。 然后枚举第一个 $0$ 的位置即可。复杂度 $O(s\\sqrt{s}+\\sum n)$ 。 F. Digital Patterns 给两个数列 $a_1,a_2,\\dots,a_n$ 和 $b_1,b_2,\\dots,b_m$ ，生成一个 $n\\times m$ 的矩阵 $c_{i,j}=a_i+b_j$ 。 查询 $c$ 有多少个子正方形满足范围内上下左右相邻的数字里没有相同的。 支持对 $a,b$ 进行区间加，查询符合条件的子正方形数量。","link":"/contest/codeforces/1928/"},{"title":"AtCoder Beginner Contest 340","text":"Solved: 7 of 7 | Rank: 107 | Performance: 2400 ID Difficulty (0-5) Topic Status Code A 0 Brute Force Solved A.cpp B 0 Brute Force Solved B.cpp C 0 DFS / Math Solved C.cpp D 1 Shortest Path Solved D.cpp E 2 Segment Tree Solved E.cpp F 1 Extended Euclidean algorithm Solved F.cpp G 3 Auxiliary Tree, Dynamic Programming solved G.cpp G - Leaf Color 给定一棵无根树 $T$ ，每个点 $u$ 有一个颜色 $a_u$ 。 问这个树有多少个子图 $T’$ ，满足： $T’$ 是一棵树，且 $T’$ 中每个叶节点（度为 $1$）的颜色都相同。 颜色相同想到虚树，枚举 $T’$ 叶子的颜色 $C$ ，$T’$ 一定是这个颜色的虚树的子图。 动态规划计算每个点 $u$ 作为 $T’$ 中最高点时有 $f_u$ 种合法方案（不考虑对 $u$ 的约束）。 并一同计算 $f_u$ 中有 $g_u$ 种方案满足 $u$ 是叶子（$u$ 只选了一个儿子）。$$f_u=\\prod_{v\\in son_u} (f_v+1) - [color_u=C], ~~ g_u=\\sum_{v\\in son_u} f_v$$如果点 $u$ 是当前枚举的颜色（可以做叶子），向答案贡献 $f_u$ 。 否则不能出现 $g_u$ 中的情况， 向答案贡献 $f_u-g_u$ 。 复杂度 $O(n\\log n)$ 。","link":"/contest/atcoder/abc/340/"},{"title":"The 48th ICPC Asia Shenyang Regional Contest","text":"补题链接, 英文题面, 中文题面, 官方题解 中期开始每个题都很胖，沈阳的题目一如既往的清新但硬核… ID Difficulty (0-5) Topic Status Code","link":"/contest/icpc/48/shenyang/"},{"title":"The 48th ICPC Asia Jinan Regional Contest","text":"补题链接, 英文题面, 中文题面, 官方题解 题目思路比较直接，代码量略大，要注意比赛节奏 ID Difficulty (0-5) Topic Status Code A 1 Brute Force Solved B 3 Sqrt Decomposition, Knapsack on Tree Upsolved C 4 Constructive Algorithms D 0 Brute Force Solved D.cpp E 3 Network Flow, Bipartite Graph Matching Solved E.cpp F 4 Divide and Conquer, Data Structures G 2 Disjoint Set Union Solved G.cpp H 3 Suffix Array Upsolved I 1 Constructive Algorithms Solved I.cpp J 5 Math K 2 Two Pointers, Data Structures Solved K.cpp L 4 Dynamic Programming, Data Structures M 2 Convex Hull Solved M.cpp D. Largest Digit两个区间长度之和大于 $9$ 答案一定是 $9$，否则暴力。 E. I Just Want… One More… 给定一个二分图，问有多少种方式添加一条边（连接左右）使得匹配数 $+1$ 。 网络流求最大匹配，对于残量网络，$S$ 联通的点数乘 $T$ 联通的点数就是答案。 二分图上跑 Dinic (也就是Hopcraft) 复杂度是 $O(m\\sqrt{n})$ 的。 G. Gifts from Knowledge 给定一个 $r$ 行 $c$ 列的 01 矩阵，对每一行选择是否进行反转。 求选择一些行进行反转方案数（允许不选择任何行），使得每一列至多有一个 1 。 反转第 $i$ 行：$b_{i, 1}, b_{i, 2}, \\cdots, b_{i, c} \\to b_{i, c}, b_{i, c-1}, \\cdots, b_{i, 1}$ 。 每个 $1$ 只有在当前列和对称列两种选项（特殊处理 $c$ 奇数中间的情况） 如果两个 $1$ 对称，那么这两个 $1$ 所以在的行反转情况必须一致（要么都反转要么都不）。 如果两个 $1$​ 位于同一列，那么一个所在的行不反转 $\\Leftrightarrow$ 另一个反转。 这是个等价关系，对每行建立反转和不反转两个点，并查集维护连通块，同一行的两个点连通无解。 考虑两行之间的关系，要么四个点都不连通，要么一定是分成两组连通。 因此连通块的情况是完全对称的，假设最终有 $2x$ 个连通块，答案是 $2^x$ 。 时间复杂度 $O(n\\alpha(n))$ 。 I. Strange Sorting 给一个排列，每次可以选一个逆序对，将这两个位置作为端点的区间排序。 构造至多 $\\lfloor\\frac{n}{2}\\rfloor$ 次操作将排列排序。 从前往后扫，每次遇到 $a_i\\neq i$，就找最大的 $j$ 满足 $a_i&gt;a_j$, 容易发现 $i,i+1$ 一定都在 $a[i\\cdots j]$ 中。 所以每次都能让两个数字归位，只需要至多 $\\lfloor\\frac{n}{2}\\rfloor$ 次。复杂度 $O(n^2)$ 。 *K. Rainbow Subarray 给定数组 $a_1,a_2,\\dots,a_n$ 和一个常数 $k$ 。 称区间 $[l,r]$ 是好的，需要满足 $a_i+1=a_{i+1}\\ \\forall i\\in[l,r)$ 。 你可以进行至多 $k$ 次操作，每次操作可以让一个数字 $+1$ 或 $-1$ 。 使得操作后，最大化最长的好区间长度。 首先令 $a_i’=a_i-i$ ，好的区间性质等价于所有 $a_i’$ 相同。 把一组数变成一样的最小代价是都变成中位数。 枚举区间左端点，另一个单调的指针维护右端点。 用对顶堆维护当前数集，如果可以扩张右端点就扩展，否则跳过这个左端点。 总扩张/删除次数 $O(n)$ ，复杂度 $O(n\\log n)$ 。 M. Almost Convex 给定点集 $S$ 满足任意三点不共线。 定义一个多边形是 $S$ 的近似凸包，当且仅当其满足： 多边形的顶点 $\\subseteq S$ ； $S$ 中的所有顶点要么在多边形上要么在多边形内。 定义 $S$ 的所有近似凸包中顶点数最少的为 $R$ 。 求有多少个 $S$ 的近似凸包 $Q$ ，满足 $|Q|\\le |R|+1$ 。 $R$ 就是 $S$ 的凸包，$Q$ 是凸包一条边向里面凹进去一个点。 按每个点进行极角排序，扫一圈如果相邻的两个点都是凸包顶点，答案 $+1$ 。 复杂度 $O(n^2\\log n)$ 。","link":"/contest/icpc/48/jinan/"},{"title":"The 48th ICPC Asia Macau Regional Contest","text":"补题链接, 英文题面, 官方题解 整体偏难，第一次以打星队的身份参赛，心态轻松抢了两个一血太爽了 ID Difficulty (0-5) Topic Status Code","link":"/contest/icpc/48/macau/"},{"title":"The 48th ICPC Asia Hefei Regional Contest","text":"补题链接, 题面, 官方题解(有些题解描述有问题) 套路题多，要熟悉使用板子 ID Difficulty (0-5) Topic Status Code A B 3 Dilworth’s Theorem, DP Upsolved B.cpp C 2 Palindrome Automaton Solved C.cpp D E 0 Brute Force Solved E.cpp F 0 Brute Force Solved F.cpp G 1 Binary Search, DP Solved G.cpp H I 2 Brute Force Solved I.cpp J 2 MST, DFS Solved J.cpp K L *B. Queue Sorting 给一个可重数集，$i\\ (1\\le i\\le 500)$ 有 $a_i\\ (\\sum a_i\\le 500)$ 个，问有多少序列符合能拆成最多两个不降子序列。 根据 Dilworth 定理，最小链分解数等于最长反链长度，即最长下降子序列长度不能超过 $2$ 。 考虑按照值的大小依次插入数字，对于每次加入的数字 $i$ ，只要不是最后一个，必定形成一个长度为 $2$ 的下降子序列。 设 $dp(i,j)$ 表示，数字 $1\\sim i$ 已经全部插入，最后一个长度为 $2$ 的下降子序列考前的那个数字的位置是 $j$ 。 令 $sum_x=\\sum_{y\\le x} a_y$ ，每次 $i+1$ 插入的时候是不能放到位置 $j$ 前面的，所以相当于对 $[j+1,sum_{i}]$ 和 $a_{i+1}$ 个位置做插板。 因为要考虑新的 $j’$ 的位置，所以枚举有 $x$ 个 $i+1$ 直接加到最后了，第一个不是最后的位置是 $k$ ，转移是$$dp(i+1,k)=\\sum_{j, x} dp(i,j)\\times {k-j-1 \\choose a_{i+1}-x-1}$$组合数的含义是，新序列灵活的位置有 $k-j-1$ 个，其中有 $a_{i+1}-x-1$ 个是 $i+1$ 。 特殊处理全都放到最后的情况：$dp(i+1,j)=dp(i,j)$ 。答案是 $\\sum dp(n,*)$ 。 复杂度 $O(n\\times \\max a_i\\times (\\sum a_i)^2)$ ，比较大但是跑不满 。 C. Cyclic Substrings 首尾相接的字符串 $S$，对每个回文子串 $t$，出现次数是 $f(t)$ ，长度是 $g(t)$ ，求 $\\sum f(t)^2\\times g(t)$ 。 回文树，一个串的出现次数就是对应节点在 $fail$ 树上的子树总出现次数。 对于循环，考虑倍长成 $S+S$，一个串只有在结束位置 $&gt;|S|$ 时才被计数，这样不会数重。 但还要保证只计数串长 $\\le |S|$ 的串，因此在统计答案的时候只有节点代表的长度符合要求才被算进答案即可（注意这并不影响该节点向其 $fail$ 树上的父节点贡献累计出现次数）。 复杂度 $O(|S||\\Sigma|)$ 。 E. Matrix Distances签到，按颜色分类计算，XY分离，排序，前缀和。 F. Colorful Balloons签到，map 统计字符串出现次数。 G. Streak Manipulation 给一个长为 $n\\ (1\\le n\\le 2\\times 10^5)$ 的 $01$ 序列，最多把 $m\\ (0\\le m\\le n)$ 个 $0$ 变 $1$ 。 对于修改后所有极长的 $1$ 连续段，最大化其中第 $k\\ (1\\le k\\le 5)$ 长的长度。 二分答案，尝试是否能搞出来至少 $k$ 个长度超过 $mid$ 的段。 令 $dp[i][j]$ 表示到 $i$ 为止，搞出 $j$ 个符合要求的段最少需要修改多少次。 由于极长，需要满足当前位置是这一段的最后一个，需要 $i=n$ 或 $i+1$ 的位置是 $0$ 。 然后找出 $i-mid$ 往前的第一个 $0$ ，然后中间这段的 $0$ 都得改成 $1$ 。 对于前面的代价，找一个 $dp[*][j-1]$ 的前缀最小值即可，记录前缀 $\\min$ 优化一下。 复杂度 $O(nk\\log n)$ 。 I. Linguistics Puzzle 给一个 $n\\ (n\\le 52)$ 进制的乘法表，每个数位都一对一映射到了一个字母，还原每个字母代表的数位，多解输出任意解。 乘法表里的数字最多两位，因此先求出每个数位在个位和十位（进的位）分别应该出现多少次。 然后对给出的字符表计算同样的结果，按照两个次数构成的 pair 分类。 这样每个字符/数位都会分到某一类中，感性理解一类里的元素不会很多，因此在此约束下，暴搜每个数位对应的字符。 复杂度我不会证明，但是真闲的没事可以打表找一下上界 。 J. Takeout Delivering 一个有边权无向图 $(n\\le 3\\times 10^5,m\\le 10^6)$ ，找一个 $1$ 到 $n$ 的路径，最小化路径上最大边权+次大边权。 枚举最大边，枚举 $1,n$ 分别连接这个边的哪个端点，次大边来自这两段路径。 变成最小化路径最大边权，答案一定在最小生成树上，从 $1,n$ 分别 DFS 一遍最小生成树求出到每个点的瓶颈边即可。 判断答案时注意要保证两段的瓶颈边权均不超过枚举的边权。 复杂度 $O(m\\log n)$ 。","link":"/contest/icpc/48/hefei/"},{"title":"1st Universal Cup, Stage 4: Ukraine","text":"Links: 补题链接, 题面, 官方题解 思维题很多，赛中要大胆猜结论，证明可以用程序 ID Difficulty (0-5) Topic Status Code A 0 Greedy Solved A.cpp B 3 Counting Solved B.cpp C D 1 Constructive Algorithms, Shortest Path Solved D.cpp E 1 Constructive Algorithms Solved E.cpp F 2 Constructive Algorithms, Brute Force Solved F.cpp G 4 Bitmasks, DP Upsolved G.cpp H I 2 Counting, DP Solved I.cpp J 3 Inversions Solved J.cpp K 0 DFS Solved K.cpp L M N A. Adjacent Product Sum 重排一个环形数列，最大化重排后的相邻两数乘积之和。 由排序不等式，感性理解一下应该是大的挨在一起，小的挨在一起。 所以排序之后左右交替放就行了，复杂度 $O(n\\log n)$ 。 *B. Binary Arrays and Sliding Sums 给定 $n,k$ , 考虑所有长度为 $n$ 的二进制序列 $a_0,a_2,\\dots,a_{n-1}$ : 令 $f_i=\\sum_{j=0}^{k-1}a_{(i+j)\\mod n}$ 得到序列 $f_0,f_1,\\dots,f_{n-1}$ ，求有多少个本质不同的 $f$ 。 $T\\ (T\\le 10^5)$ 组询问，每次问一对 $n,k\\ (2 \\le k &lt; n \\le 10^6 )$ 。 下述过程中，所有下标均在模 $n$ 意义下。 有 $a_i-a_{i-k}=f_i-f_{i-1}\\in[-1,1]$ ，当不为 $0$ 时一定能确定 $a_i$ 和 $a_{i-k}$ 的取值，否则两者可能同为 $0$ 或同为 $1$ 。 按照间隔为 $k$ 分组，会分成 $g=gcd(n,k)$ 个“环”，每个环长为 $n/g$ 。 每个环中只要有一个位置能确定（有一个 $f_i-f_{i-1}\\neq 0$ ），整个环的取值都能确定。 考虑每个环对 $f$ 的贡献，容易发现对于每连续 $k$ 个位置，每个环都恰好占走了 $k/g$ 个位置。 因此对于某个 $a$ 数列，我们去考虑和他 $f$ 数组一致（冲突）的数列的特征，按照环考虑： 对于可以从 $f$ 唯一确定的环，显然这些位置必须和 $a$ 保持一致。 否则是全 $0$ / 全 $1$ 环（称作特殊环），由于每个环对 $f$ 的贡献位置个数一致，所以只要全 $1$ 环的“环个数”一致即可。 因此我们按 $f$ 划分出等价类：特殊环位置的集合一致（个数+下标），全 $1$ 环的个数一致，非特殊环对应位置完全一致。 因此对应特征计数：枚举特殊环数 $k$ ，特殊环下标集选法 ${g\\choose k}$，全 $1$ 环个数选法 $(k+1)$ ，非特殊环方案数 $(2^{n/g}-2)^{g-k}$ 。$$\\begin{array}{ll}ans &amp;= \\sum_{k=0}^g(k+1){g\\choose k}(2^{n/g}-2)^{g-k}\\\\&amp;= \\sum_{k=0}^g{g\\choose k}(2^{n/g}-2)^{g-k}+ \\sum_{k=0}^g k\\times \\frac{g!}{k!(g-k)!}\\times (2^{n/g}-2)^{g-k}\\\\&amp;= \\sum_{k=0}^g{g\\choose k}(2^{n/g}-2)^{g-k}+ g\\sum_{k=1}^g {g-1\\choose k-1}\\times (2^{n/g}-2)^{g-k}\\\\&amp;=((2^{n/g}-2) + 1)^g + g\\times ((2^{n/g}-2) + 1)^{g-1}\\end{array}$$快速幂计算即可，复杂度 $O(T\\log n)$ 。 D. Distance Parities 一个 $n\\ (n\\le 500)$ 个点的无向图，给定任意两点最短路奇偶性，构造一个图符合要求。 构造一个图 $G$ ：对于任意两点，给定性质中如果要求是奇数距离就给两点间加一条边，否则不加。 证明：这个图 $G$ 符合要求 $\\Leftrightarrow$ 存在一个图 $G’$ 符合要求。 左推右显然，证明右推左，若 $G’$ 符合要求，那么对于任意点对 $u,v$ ： 若距离为奇数，则在 $G$ 中两点距离为 $1$ 符合要求； 若距离为偶数，则必然存在一个点 $w$ ，在 $G’$ 中到两个点距离为奇数（例如 $u\\to v$ 最短路上，除掉 $u,v$ 的第一个点），则在 $G$ 中 $w$ 和两个点都有一条边，因此 $G$ 中两点距离为 $2$ 符合要求。 因此判断 $G$ 是否合法即可，Floyd-Warshall 复杂度 $O(n^3)$ 。 E. Excellent XOR Problem 长度为 $n\\ (n\\le 10^5)$ 的数列 $a_i\\ (0\\le a_i&lt; 2^{30})$ ，将数列划分成多于一段，使得每段异或和两两不同。 如果全部异或和不为 $0$ ，任意切分两段异或和不同。 否则考虑从左往右第一个不为 $0$ 的数字 $a_x$ ： 对于某个 $p\\in[x+1,n-1]$ ，如果 $[x+1,p]$ 异或和不为 $0$ 也不为 $a_x$ ，那么找到了一种分三段的方法。 否则，数列中除了 $0$ 以外，是偶数个 $a_x$ ，这种情况一定无解。 所以找到 $a_x$ 之后扫一遍就可以了，复杂度 $O(n)$ 。 F. F*** 3-Colorable Graphs 给一个连通二分图 $K_{n,m}\\ (2\\le n,m\\le 10^4)$，问最少加多少边使得这个图不能三染色。 不加边，二分图可以二染色。 加一条边，随便把这条边的一个端点染成第三种颜色就保证了相邻不同，此时可以三染色。 加两条边，如果有公共点，把一个公共点染成第三种颜色；否则四个不同的端点如果构成了 $K_4$ ，则需要四染色，否则四个点中至少有一对点没有边相连，把这两个点都染成第三种颜色后，其他维持二分图染色不变，依然可以三染色。 加三条边，因为是连通二分图且两侧都有至少两个点，必定存在长度为 $3$ 的链，必能补成 $K_4$ ，需要四染色。 因此如果能加两条边补出 $K_4$ 答案就是 $2$ ，否则答案是 $3$ 。 因为二分图中不能有奇环，因此唯一的情况是图中存在四元环。 考虑暴力，枚举左侧点 $u$ ，枚举 $u$ 的邻居 $v$ ，枚举 $v$ 的邻居 $u’$ ，当 $u’\\neq u$ 时对 $u’$ 累加计数器。 当遇到一个 $u’$ 被累计了两次的时候，就找到了答案。否则不存在四元环。 暴力复杂度是对的，对于每个 $u$ ，每个 $u’$ 只会枚举到 $O(1)$ 次，否则找到答案结束，因此复杂度是 $O(n^2)$ 的。 当然也可以直接上四元环计数，复杂度 $O(m\\sqrt{m})$ 。 *G. Graph Problem With Small n 给一个 $n\\ (2\\le n\\le 24)$ 个点的无向图，判断是否任意点对间存在从一个出发另一个结束的哈密顿路径。 设 $dp[S][u][v]=0/1$ 表示经过的点集为 $S$ ，起点为 $u$ 终点为 $v$ 的路径是否存在，这个dp是 $O(n^32^n)$ 的。 进一步设 $dp[S][u]$ 表示经过点击为 $S$ ，起点为 $u$ 的可能的终点集合，新 dp 的值相当于之前 dp 的值的状压。 初始化 $dp[{u}][u] = {u}$ ，求 $dp[S][u]$ 时考虑第一步走 $u\\to v$ ，那么方程是：$$dp[S][u] = \\bigcup_{v\\in S} dp[S/{u}][v]$$ 枚举 $S,u$ 之后枚举 $u$ 邻居 $v$ ，现在复杂度降低到了 $O(n^22^n)$ 。 换个思路，直接考虑有哪些 $v$ 在 $dp[S][u]$ 中，我们考虑路径的最后一步 $w\\to v$ ，需要保证 $w$ 在 $S/{v}$ 对应状态的可能终点中（即 $dp[S/{v}][u]$ 中），并且 $w$ 和 $v$ 有边相连。 预处理每个人的邻居集 $N_i$ ，条件等价于 $dp[S/{v}][u]$ 和 $N_v$ 有交，即方程是：$$dp[S][u] = \\bigcup_{dp[S/{v}][u]\\ \\cap\\ N_v\\neq \\emptyset} {v}$$枚举 $S,u,v$ 判断是 $O(1)$ 的，因此这个转移的思路复杂度也是 $O(n^22^n)$ 的。 这个转移的好处是 $dp[S][u]$ 的值只依赖于 $dp[*][u]$ ，换句话说，可以 $O(n2^n)$ 求出对某个特定 $u$ 的所有 dp 值。 考虑 $O(n2^n)$ 求出所有的 $dp[*][0]$ ，即从 $0$ 出发的所有可能的集合的可能的终点。 考虑一条 $u$ 开始 $v$ 结束的哈密顿路径，必定经过 $0$ ，点集可以拆成两段 $S$ 和 $U/S \\cup {0}$ （互补集合都加上 $0$ ）。 因此对于 $dp[S][0]$ 中的每个点 $u$ ，都可以和 $dp[U/S\\cup{0}][u]$ 中的每个点 $v$ 匹配。 再次使用状压的思路，设 $ans[u]$ 表示 $u$ 出发可能的哈密顿路径终点集合。 枚举 $S$ ，枚举 $S$ 中的点 $u$ ，令 $ans[u] = ans[u] \\operatorname{or} dp[U/S\\cup{0}]$ 即可。 这样总复杂度神奇的降到了 $O(n2^n)$ ，空间复杂度 $O(2^n)$ 。 由于 1s 需要的计算量达到了 2e8 所以需要比较精细的实现，实测不同的实现方法常数甚至有 5 倍的差距。 可能的卡常方法： $S$ 不包含 $0$ 的状态是没有用的，所以可以删去一半的集合，$2^n\\to 2^{n-1}$ 卡掉一半的常数。 多使用位运算及 __builtin 系列函数加快枚举集合内元素，而不直接 $O(n)$ 枚举： for (int ts = S, v; ts; ts &amp;= ~-ts) v = __builtin_ffs(ts) - 1; I. Increasing Grid 一个 $n\\times m\\ (1\\le n\\times m\\le 2\\times 10^5)$ 的矩阵，每个位置的数字在 $1\\sim n+m$ 之间。 现给定一些位置的取值，问其他位置有多少种不同的合法填法，使得每行从左往右递增，每列从上到下递增。 观察发现 $A_{ij}$ 的值只能是 $i+j-1$ 或 $i+j$ ，选了 $i+j-1$ 左上角的所有数字就确定了，否则右下角所有数字都确定了。 因此所有数字分成两类，一类能推出所有左上角，一类能推出所有右下角，先把冲突无解的情况判掉。 因此存在一个从左下到右上的分界线，每次向上或向右，计数矩阵填法等价于计数分界线选法。 处理出来每个位置是必定在左上/必定在右下/都可以，然后从左下向右上dp分界线方案数，复杂度 $O(n\\times m)$ 。 注意一个位置如果上方必须是边界就不能往右延伸了。 *J. Jewel of Data Structure Problems 给定一个排列 $(1\\le n,q \\le 2\\times 10^5)$，支持交换两个位置，查询最长的子序列，其逆序对数为奇数。 结论大杂烩。 整体逆序数为 $0$ 的情况（排列为 $1,2,\\dots,n$ ），答案为 $-1$ 。 如果整个排列逆序对数为奇数，答案是 $n$ 。 否则考虑每个数 $p_i$ 产生的逆序对数 $c_i$ （前面比他大的个数+后面比他小的个数），如果存在一个 $c_i$ 是奇数，删掉对应的 $p_i$ 即可，答案是 $n-1$ 。 否则所有 $c_i$ 都是偶数，考虑序列中的任意一个逆序对 $(p_i,p_j)$ ，这个逆序对在 $c_i,c_j$ 中都被考虑了一次，所以把这两个位置删掉，逆序对的减少量一定是奇数，所以答案最差 $n-2$ 。 于是只需要维护： 当前逆序数是否为 $0$ （排列是否为 $1,2,\\dots,n$ ）：维护 $p_i\\neq i$ 的个数，交换两个操作下可以 $O(1)$ 维护。 总逆序数奇偶性：考虑交换 $p_i,p_j$ ，容易发现 $p_k\\ (k\\in (i,j))$ 参与的逆序对数奇偶性不会发生变化（按值和 $p_i,p_j$ 的关系分三段讨论），而 $p_i,p_j$ 的交换必然导致增加/删除了一个由 $p_i,p_j$ 构成的逆序对，因此每次操作总逆序数奇偶性一定改变，即交换两个元素排列的奇偶性一定改变。而一个排列可以通过 $n-$ 环数次交换变成 $1,2,\\dots,n$ ，所以其逆序对数的奇偶性与 $n-$ 环数相同，初始化复杂度 $O(n)$ 。 是否有一个 $c_i$ 为奇数（所有的 $c_i$ 的奇偶性）：考虑 $c_i$ 的计算方法，假设 $i$ 前面比 $p_i$ 大的数字有 $x$ 个，那么 $c_i=x+[p_i-1-(i - 1 - x)]=2x+p_i-i$ ，所以 $c_i$ 的奇偶性只和 $i,p_i$ 有关，只有交换两个的操作可以 $O(1)$ 维护。 总复杂度 $O(n+q)$ ，不需要任何数据结构，实在优雅。 K. King of Swapping 对于 $n$ 的排列，给定 $m$ 个操作 $a_i,b_i$ 代表如果 $p_{a_i}&gt;p_{b_i}$ 则可以交换这两个数。 问使用给定的操作任意多次，是否能把任意一个 $n$ 的排列变成任意另一个 $n$ 的排列。 其实是问能否交换任意两个位置（反证即可），把操作看成有向边，也就是要判断图是否强连通。 判一下原图和反图 $1$ 是否都能到所有点即可（这是整个图强连通的等价命题），复杂度 $O(n)$ 。","link":"/contest/ucup/1/4/"},{"title":"The 48th ICPC Asia Nanjing Regional Contest","text":"补题链接, 英文题面, 官方题解 注意比赛节奏，写代码要简化讨论，为什么袋鼠题我每年都不太会 ID Difficulty (0-5) Topic Status Code","link":"/contest/icpc/48/nanjing/"},{"title":"The 9th CCPC Harbin Onsite","text":"补题链接, 英文题面, 官方题解 本赛季第一场线下赛，最后卡在了一个拉格朗日函数，最优化课上学过的全忘了… ID Difficulty (0-5) Topic Status Code","link":"/contest/ccpc/9/harbin/"},{"title":"The 9th CCPC Guilin Onsite","text":"补题链接, 英文题面, 官方题解 题不难，但对常用结论要有敏感度，注意积累总结套路 ID Difficulty (0-5) Topic Status Code","link":"/contest/ccpc/9/guilin/"},{"title":"Hello World","text":"「 Hello, the lovely world. 」 「 Stay hungry, Stay foolish. 」 Inline FormulaOne day you are surviving in the wild. After a period of exploration, you determine a safe area, which is a convex hull with $n$ vertices $P_1,P_2,\\dots,P_n$ in counter-clockwise order and any three of them are not collinear. Now you notice that there will be $q$ airdrop supplies, and for the $i$-th supply, its delivery range is described by a circle $C_i$ , which means the supply will landed with uniformly probability among all the points with a real number coordinate inside $C_i$. You need supplies so much that you decide to predetermine a starting point for each supply, and the starting point of two different supplies can be different. Every starting point should be inside the safe area and have the smallest expected value of the square of the Euclidean distance to the corresponding supply landing point. Recall that On a two-dimensional plane, the Euclidean distance between two points $(x_1,y_1)$ and $(x_2,y_2)$ is $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$. If both coordinates of a point are all integers, then we call this point an integer point. Block Formula$$\\int \\frac{dx}{cos^2x}=\\int sec^2xdx=tan x+C\\$$ $$\\int \\frac{dx}{sin^2x}=\\int csc^2xdx=-cot x+C$$ $$\\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = 0}^{E - i} (-1)^{j} {M - i \\choose j} {N - iS \\choose jS} \\frac{(jS)!}{(S!)^{j}} (M - i - j)^{N - iS - jS}$$ $$= \\sum\\limits_{i = 0}^{E} w[i]{M \\choose i} {N \\choose iS} \\frac{(iS)!}{(S!)^{i}} \\sum\\limits_{j = i}^{E} (-1)^{j - i} {M - i \\choose j - i} {N - iS \\choose jS - iS} \\frac{(jS - iS)!}{(S!)^{j - i}} (M - j)^{N - jS}$$ Matrix$$\\begin{bmatrix}(\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; \\cdots &amp; (\\omega_n^0)^{n-1}\\\\(\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; \\cdots &amp; (\\omega_n^1)^{n-1}\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\(\\omega_n^{n-1})^0 &amp; (\\omega_n^{n-1})^1 &amp; \\cdots &amp; (\\omega_n^{n-1})^{n-1}\\end{bmatrix}\\begin{bmatrix}a_0\\\\a_1\\\\\\vdots\\\\a_{n-1}\\end{bmatrix}=\\begin{bmatrix}A(\\omega_n^0)\\\\A(\\omega_n^1)\\\\\\vdots \\\\A(\\omega_n^{n-1})\\end{bmatrix}$$ To prevent escaping, you need to use \\\\\\\\ to make a new line rather than \\\\ . LinkFor more about the Mathjax symbols, refer to: The Comprehensive LaTeX Symbol List. Code Highlight &amp; Fold12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!","link":"/misc/hello-world/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Segment Tree","slug":"Segment-Tree","link":"/tags/Segment-Tree/"},{"name":"Counting","slug":"Counting","link":"/tags/Counting/"},{"name":"Bitmasks","slug":"Bitmasks","link":"/tags/Bitmasks/"},{"name":"Auxiliary Tree","slug":"Auxiliary-Tree","link":"/tags/Auxiliary-Tree/"},{"name":"Strings","slug":"Strings","link":"/tags/Strings/"}],"categories":[{"name":"Contest","slug":"Contest","link":"/categories/Contest/"},{"name":"Summary","slug":"Summary","link":"/categories/Summary/"},{"name":"UCUP","slug":"Contest/UCUP","link":"/categories/Contest/UCUP/"},{"name":"Codeforces","slug":"Contest/Codeforces","link":"/categories/Contest/Codeforces/"},{"name":"CCPC","slug":"Contest/CCPC","link":"/categories/Contest/CCPC/"},{"name":"AtCoder","slug":"Contest/AtCoder","link":"/categories/Contest/AtCoder/"},{"name":"ICPC","slug":"Contest/ICPC","link":"/categories/Contest/ICPC/"},{"name":"AtCoder Beginner Contest","slug":"Contest/AtCoder/AtCoder-Beginner-Contest","link":"/categories/Contest/AtCoder/AtCoder-Beginner-Contest/"}],"pages":[{"title":"About Me","text":"Hello, I am Yixiong Gao(高义雄). Welcome to my blog. I’m a Christian and I’m quite grateful for the abundance of grace from God in my life. Now I worship and serve in the Putonghua Ministry of St. Andrew’s Church Kowloon, a thriving Mandarin-speaking community. I’m now a fourth-year undergraduate student in Computer Science at Hangzhou Dianzi University. I am broadly interested in theoretical computer science. Currently, I am focusing on combinatorial optimization problems. I’m a contestant in competitive programming. I won 4 gold medals in the International Collegiate Programming Contests (ICPC) Regional Contests, and 3 gold medals in the China Collegiate Programming Contests (CCPC). This is my Codeforces profile. I’m also a problem setter of competitive programming. I’ve set problems for several official contests and many training contests. Date Contest Name Links Sep/17/2023 The 48th ICPC Asia EC Regionals Online Selection Contest (I) Problems Tutorial(Chinese) Jun/04/2023 The 6th Guangxi Collegiate Programming Contest Problems Tutorial(Chinese) Jun/26/2022 The 5th Guangxi Collegiate Programming Contest Problems Tutorial(Chinese) Aug/01/2023 2023 HDU Multi-University Training Contest 5 Problems Tutorial(Chinese) Jan/27/2023 2024 CityU Programming Contest Problems More information can be found in my CV (Last updated: Jan 21, 2024).","link":"/about/index.html"}]}